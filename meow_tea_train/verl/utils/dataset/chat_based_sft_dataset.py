# Copyright 2024 Bytedance Ltd. and/or its affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
SFT dataset
- We assume user pass a single parquet file.
- We load all the data into the memory.
Each parquet file contains
"""

from typing import Union

import pandas as pd
import re
import torch
from omegaconf.listconfig import ListConfig
from torch.utils.data import Dataset
from transformers import PreTrainedTokenizer

from verl.utils import hf_tokenizer
from verl.utils.fs import copy_to_local
from verl.utils.model import compute_position_id_with_mask


class ChatBasedSFTDataset(Dataset):
    """
    This is an in-memory SFTDataset

    Arguments:
        config (OmegaConf): the data config
    """

    def __init__(self, parquet_files: Union[str, ListConfig], tokenizer, config):
        config = config or {}
        self.truncation = config.get("truncation", "error")
        self.max_length = config.get("max_length", 1024)
        self.use_shm = config.get("use_shm", False)

        # Get messages_key from the new multiturn config structure
        chat_based_config = config.get("chat_based", {})
        self.messages_key = chat_based_config.get("messages_key", "messages")

        assert self.truncation in ["error", "left", "right"]

        if not isinstance(parquet_files, ListConfig):
            parquet_files = [parquet_files]

        self.parquet_files = parquet_files
        if isinstance(tokenizer, str):
            tokenizer = hf_tokenizer(tokenizer)
        self.tokenizer: PreTrainedTokenizer = tokenizer

        self._download()
        self._read_files_and_process()

    def _download(self):
        for i, parquet_file in enumerate(self.parquet_files):
            self.parquet_files[i] = copy_to_local(parquet_file, verbose=True, use_shm=self.use_shm)

    def _read_files_and_process(self):
        def series_to_item(ls):
            import numpy
            import pandas

            while isinstance(ls, (pandas.core.series.Series, numpy.ndarray)) and len(ls) == 1:
                ls = ls[0]
            return ls

        dataframes = []
        for parquet_file in self.parquet_files:
            dataframe = pd.read_parquet(parquet_file)
            dataframes.append(dataframe)
        self.dataframe = pd.concat(dataframes)

        # Extract messages list from dataframe
        self.messages = self.dataframe[self.messages_key].apply(series_to_item).tolist()

    def _truncate_system_template(self, text: str) -> str:
        """
        Given string generated by chat template, truncate the system prompt block.
        Example:
            <im_start>system ... <im_end><im_start>user ... <im_end><im_start>assistant
            becomes ->
            <im_start>user ... <im_end><im_start>assistant
        """
        pattern = r'<\|im_start\|>system\n.*?<\|im_end\|>\n'
        return re.sub(pattern, '', text, flags=re.DOTALL)

    def __len__(self):
        return len(self.messages)

    def __getitem__(self, item):
        tokenizer = self.tokenizer
        messages = self.messages[item]

        # apply chat template
        prompt_chat = messages[:-1]

        # string
        prompt_chat_str = tokenizer.apply_chat_template(prompt_chat, add_generation_prompt=True, tokenize=False)
        prompt_chat_str = self._truncate_system_template(prompt_chat_str)
        assert messages[-1]["role"] == "assistant"
        response_chat_str = messages[-1]["content"] + tokenizer.eos_token

        # tokenize
        prompt_ids_output = tokenizer(prompt_chat_str, return_tensors="pt", add_special_tokens=False)
        prompt_ids = prompt_ids_output["input_ids"][0]
        prompt_attention_mask = prompt_ids_output["attention_mask"][0]

        response_ids_output = tokenizer(response_chat_str, return_tensors="pt", add_special_tokens=False)
        response_ids = response_ids_output["input_ids"][0]
        response_attention_mask = response_ids_output["attention_mask"][0]

        prompt_length = prompt_ids.shape[0]
        response_length = response_ids.shape[0]

        input_ids = torch.cat((prompt_ids, response_ids), dim=-1)
        attention_mask = torch.cat((prompt_attention_mask, response_attention_mask), dim=-1)

        # padding to max length
        sequence_length = input_ids.shape[0]
        if sequence_length < self.max_length:
            padded_input_ids = (
                torch.ones(size=(self.max_length - sequence_length,), dtype=input_ids.dtype)
                * self.tokenizer.pad_token_id
            )
            padded_attention_mask = torch.zeros(size=(self.max_length - sequence_length,), dtype=attention_mask.dtype)

            input_ids = torch.cat((input_ids, padded_input_ids))
            attention_mask = torch.cat((attention_mask, padded_attention_mask))
        elif sequence_length > self.max_length:
            if self.truncation == "left":
                # actually, left truncation may not be reasonable
                input_ids = input_ids[-self.max_length :]
                attention_mask = attention_mask[-self.max_length :]
            elif self.truncation == "right":
                input_ids = input_ids[: self.max_length]
                attention_mask = attention_mask[: self.max_length]
            elif self.truncation == "error":
                raise NotImplementedError(f"{sequence_length=} is larger than {self.max_length=}")
            else:
                raise NotImplementedError(f"Unknown truncation method {self.truncation}")

        # Extract response_ids from the final input_ids
        response_start_idx = min(prompt_length, input_ids.shape[0])
        response_ids_raw = input_ids[response_start_idx:].clone()

        # Pad response_ids to a fixed maximum response length (right padded)
        max_response_length = self.max_length // 2  
        if response_ids_raw.shape[0] < max_response_length:
            padding = torch.full(
                (max_response_length - response_ids_raw.shape[0],), 
                self.tokenizer.pad_token_id,
                dtype=response_ids_raw.dtype
            )
            response_ids = torch.cat([response_ids_raw, padding])
        else:
            response_ids = response_ids_raw[:max_response_length]

        # Extract prompt_ids from the final input_ids
        prompt_ids_raw = input_ids[:response_start_idx].clone()
        # Pad prompt_ids to a fixed maximum prompt length (left padded)
        max_prompt_length = self.max_length
        if prompt_ids_raw.shape[0] < max_prompt_length:
            padding = torch.full(
                (max_prompt_length - prompt_ids_raw.shape[0],), 
                self.tokenizer.pad_token_id,
                dtype=prompt_ids_raw.dtype
            )
            prompt_ids = torch.cat([padding, prompt_ids_raw])
        else:
            prompt_ids = prompt_ids_raw[:max_prompt_length]
        
        position_ids = compute_position_id_with_mask(attention_mask)

        loss_mask = attention_mask.clone()
        if prompt_length > 1:
            # mask out prompt for SFT.
            loss_mask[: min(prompt_length, loss_mask.size(0)) - 1] = 0
        # mask out the last token in response
        loss_mask[min(prompt_length + response_length, loss_mask.size(0)) - 1] = 0

        return {
            "input_ids": input_ids,
            "attention_mask": attention_mask,
            "position_ids": position_ids,
            "loss_mask": loss_mask,
            "prompt_ids": prompt_ids, 
            "response_ids": response_ids
        }